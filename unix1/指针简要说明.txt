内存的表示


计算机的最小表示单位是 位(bit)
1 bit 可以表示 0 1 两种状态

计算机的内存通常用 字节(Byte) 来表示容量
1 Byte 等于 8 bit
8 bit 可以表示 0-255 个状态，相当于可以表示 256 个不同的数字

常用单位转换如下
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB


在 C 语言中，对内存的访问是以 地址 的形式
一个地址可以表示 1 Byte
也就是说内存相当于一个大的数组，数组中每个元素可以存 256 这么大的一个数字，内存的地址相当于数组的下标，从 0 开始
比如 1KB 内存就相当于 0-1023 个下标的数组，数组中每个元素是一个 0-255 的数字




变量的存储

C 语言中的变量，都是存在内存中的
比如下面这个变量 a，假设它的内存地址是 100，那么赋值的时候相当于往内存地址 100 的内存中存入了数字 1
int a = 1;

看下面这个短例
int b = a;
b = b + 10;
当我们创建一个新变量 b 并且把 a 赋值给 b 的时候
假设 b 的内存地址是 200
那么相当于把内存地址 100 里面存的数字 1 复制到内存地址 200 的内存中去
接下来 b = b + 10，操作的也是内存地址 200 里的数据，和变量 a（内存地址 100）无任何关系



C 语言中有不同的数据类型，不同的数据类型占用的字节数是不一样的
简单举 2 个例子
char 类型占用 1 字节
int 类型一般来说占用 4 字节（是的，C 语言设计中不规定 int 的长度）


指针，实际上就是一个内存地址
由于我们现在使用的是 64 位的 CPU 和操作系统，所以内存地址是 64 位的数字
任意类型的指针变量，都必须是一个 64 位（也就是 8 Byte）的数字
即便这个地址是 100，也得用 8 Byte 的内存来装这个变量

声明指针的时候为什么要有类型呢？
因为我们可以对指针做加减法
int 类型的指针，做计算 +1 的时候相当于实际的内存地址 +4
char 类型的指针，做计算 +1 相当于实际的内存地址 +1
指针要类型主要就是为了在这里简化一下




指针的使用

来看下面这 2 个代码片段
看明白，不懂的地方可以在群内讨论

void
add1(int a) {
    a = a + 1;
}

void
add2(int *a) {
    *a = *a + 1;
    // 打印指针 a 的值使用 %p
    printf("int *a  Address %p \n", a);
}

int
main(void) {
    int i = 6;
    // 根据我们之前的描述，这里的 add1(i) 只是把 i 的内容复制给参数 a
    // 函数内的参数 a + 1 与函数外的 i 没有关系
    // 所以函数调用结束后，i 仍然是 6
    add1(i);


    // 根据我们之前的描述，这里的 add2(&i) 只是把 &i 的内容复制给参数 a
    // &i 是变量 i 的内存地址，假设是 300
    // 相当于函数内的指针变量 a 被赋值为 300
    // *a 表示取指针 a 代表的内存地址（也就是 300）里面存的数据（也就是 6）
    // 对 *a 赋值等于往指针 a 代表的内存地址里面存数据
    // 也就相当于改变了变量 i
    // 所以这个 add2 调用结束后，i 的值会是 7
    add2(&i);

    return 0;
}




 int *p; // 一个指针指向 int/一个 int 类型的指针
    int **p; // 一个指针指向 int*/ 一个 int* 类型的指针/一个int指针类型的指针/
    int ***p; // 一个指针指向 int**

    char v;
    char *p; // sizeof(p) == 8; sizeof(*p) == 1; sizeof(p[0]) == 1
    char **pp; // sizeof(pp) == 8; sizeof(*pp) == 8; sizeof(**pp) == 1;
    char ***ppp; // sizeof(ppp) == 8; sizeof(*ppp) == 8; sizeof(**ppp) == 8; sizeof(***ppp) == 1;
    p = &v;
    pp = &p;
    ppp = &pp;

    int *a = (int*)malloc(sizeof(int) * 4); // 4元素数组
    a[3] = 1;
    
    int **matrix = (int**)malloc(sizeof(int*) * 4);  // 4元素矩阵
    matrix[0] = (int*)malloc(sizeof(int) * 4); // 第1行
    matrix[1] = (int*)malloc(sizeof(int) * 4); // 第2行
    matrix[2] = (int*)malloc(sizeof(int) * 4); // 第3行
    matrix[3] = (int*)malloc(sizeof(int) * 4); // 第4行
    matrix[0][0] = 0;
    matrix[0][1] = 0;
    matrix[3][3] = 15;

