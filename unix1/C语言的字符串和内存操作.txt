字符的表示

C 语言中表示字符是使用 char 类型，例子如下（注意使用单引号）
char c = 'a';
根据《指针简要说明》中所述，变量 c 占用 1 字节
在内存中，所有数据都是数字
'a' 这个字符实际上用数字 97 来表示
所以上面那一句赋值也可以写成下面这样
char c = 97;


数字和字符的对应关系，叫做 编码
C 语言中默认的编码 ASCII，说明链接如下（不用看）
https://baike.baidu.com/item/ASCII/309296





C 语言中的字符串

C 语言中的字符串实际上是一个以 '\0' 结尾的特殊字符数组
（注意 '\0' 是一个特殊表示方法，因为打不出这个字符所以用 \0 表示）
声明的方式如下（注意必须使用双引号）
这一句声明了一个字符串（实际上是一个特殊字符数组）
它包含了 4 个字符（ a b c 和末尾自动加的 '\0'）
char *s = "abc";

实际上内存中分配了 4 字节，s 是首字节的地址
由于 s 实际上只是一个地址（指针），并不能知道字符串总长度
所以 C 语言设计为 '\0' 表示结尾（否则不可能知道什么时候结束）






指针与数组

上面说了 s 是一个指针，又是一个特殊字符数组
实际上在很多情况下，可以把指针当作数组
s[0] 是 'a'，相当于 *s
s[1] 是 'b'，相当于 *(s+1)
s[2] 是 'c'，相当于 *(s+2)
s[3] 是 '\0'，相当于 *(s+3)

但是需要注意的是下面这样的写法是一个特殊写法
char *s = "abc";

这样的情况下，只能读取 s[0] s[1] 不能写入 s[0]
比如 s[0] = 'z' 这样的写法是不可以的，不支持修改，只能读取








内存的操作

函数结束后，函数内所有的变量都会被系统回收
所以在很多时候需要申请一块函数结束后都不会被回收的内存
比如要返回一个字符串，就只能申请内存然后返回首地址指针

申请内存需要包含 stdlib.h 头文件，并且使用 malloc 函数

下面的例子申请了 4 字节内存，sizeof(char) 是为了计算 char 类型的长度
char *s = malloc(sizeof(char) * 4);
s[0] = 'a';
s[1] = 'b';
s[2] = 'c';
s[3] = '\0';


下面的例子申请了 12 字节内存，sizeof(int) 是为了计算 int 类型的长度
（我们之前说过 C 语言未规定 int 类型的长度，但在我们电脑上一般是 4，这里我们假设它是 4）
int *n = malloc(sizeof(int) * 3);
n[0] = 11;
n[1] = 22;
n[2] = 33;

假设返回的地址是 500，那么变量 n （这是一个指针变量）里面存储的数据就是 500
因为 n 是 int 指针类型，所以 *(n+1) 也就是 n[1] 相当于 n 的值 +4
也就是说 n[1] = 22 相当于往内存地址 504 写入数据 22






字符串拼接的例子
char *
stringCat(char *s1, char *s2) {
    // 求出 s1 s2 的长度
    int len1 = stringLength(s1);
    int len2 = stringLength(s2);

    // 拼接后的新字符串 s3 的长度要多 1 个用于放末尾的 '\0'
    int len3 = len1 + len2 + 1;
    char *s3 = malloc(sizeof(char) * len3);

    // 循环把 s1 里的字符都复制到 s3 中
    for (int i = 0; i < len1; i++) {
        *(s3 + i) = *(s1 + i);
        // 也可以写为 s3[i] = s1[i]
    }

    // 循环把 s1 里的字符都复制到 s3 后面
    for (int i = 0; i < len2; i++) {
        *(s3 + i + len1) = *(s2 + i);
        // 也可以写为 s3[i+len1] = s2[i]
    }

    // 最后一位要设置为 '\0' 才是一个合格的字符串
    *(s3 + len3 - 1) = '\0';
    // 也可以写为 s3[len3-1] = '\0'

    return s;
}

在上面的 stringCat 中，你可能会觉得下标计算很容易出错
其实这事很简单，你在纸笔上计算出公式再换成代码就好了
如果强行直接用代码写，那我也做不出来

例如下面两个字符串长度分别为 3 和 4
char *s1 = "abc";
char *s2 = "1234;
那么新字符串包含末尾的 \0 的话长度就是 8
s1 复制到 s3 很简单不必说
s2 的下标 0 对应的是 s3 的下标 3
s2 的下标 1 对应的是 s3 的下标 4
s2 的下标 2 对应的是 s3 的下标 5
s2 的下标 3 对应的是 s3 的下标 6

也就是 s2 的下标 n 对应 s3 的下标 n + 3，这个 3 是 s1 的长度

s3 末尾的 \0 的下标也就是 s3 的长度 - 1
因为数组长度为 n 的话，那么数组最后一个元素的下标是 n-1（这个很好理解，自己代入一下就好了）


